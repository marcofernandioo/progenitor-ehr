import * as crypto from 'crypto';
import * as I from '../interface'

export default class Transaction implements I.ITransaction {
    sender: String;
    timestamp: Number;
    medicalRecord: I.IMedicalRecord;
    hash: String="";
    signature: String="";

    constructor(_sender: String, _medicalRecord: I.IMedicalRecord, privateKey: any) {
        this.sender = _sender;
        this.timestamp = Date.now();
        this.medicalRecord = _medicalRecord;
        this.hash = this.calculateTxHash();
        console.log(_medicalRecord);
    };

    // Sign a transaction using the private key.
    async signTx (privateKey: string) {
        // We're checking if the public key could be generated by the given private key.
        // Because we want only the Sender of the tx be able to sign it.
        // Other users cannot sign tx other than their own.

        // const publicKey = this.derivePublicKey(privateKey);
        // if (publicKey !== this.sender) {
        //     throw new Error("Sender does not match with given keys.");
        // }

        const signer = crypto.createSign('sha256');
        this.hash = this.calculateTxHash();
        signer.update(Buffer.from(this.hash));
        const signature = signer.sign(privateKey);
        this.signature =  signature.toString('hex');
    }

    // PROD: Move this to util files. Transaction hash, not yet signed by sender.
    calculateTxHash(): String {
        return crypto.createHash('sha256').update(this.sender + this.medicalRecord.toString() + this.timestamp).digest('hex');
    }

    derivePublicKey(privateKey: string): string {
        try {
            const publicKey = crypto.createPublicKey(privateKey);
            return publicKey.export({ type: 'spki', format: 'pem' }).toString();
        } catch (error: any) {
            throw new Error('Failed to derive public key: ' + error.message);
        }
    }

    // We sign the transaction hash using private key.
    sign(key: any) {
        if (key.getPublic('hex') !== this.sender)
            throw new Error("Sender does not match with given keys.");
        const sign = key.sign(this.hash, 'base64');
        return sign.toDER('hex');
    }

}