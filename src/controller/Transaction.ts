import * as crypto from 'crypto';
const forge = require('node-forge');
import * as I from '../interface'

export default class Transaction implements I.ITransaction {
    sender: String;
    timestamp: Number;
    body: any;
    hash: String;
    signature: String;

    constructor(_sender: String, _body: any, privateKey: any) {
        this.sender = _sender;
        this.timestamp = Date.now();
        this.body = _body;
        // this.signature = this.sign2(privateKey);
        this.signature = this.signTx(privateKey);
        this.hash = this.calculateTxHash();
    }

    // We sign the transaction hash using private key.
    sign(key: any) {
        if (key.getPublic('hex') !== this.sender)
            throw new Error("Sender does not match with given keys.");
        const sign = key.sign(this.hash, 'base64');
        return sign.toDER('hex');
    }

    // Sign a transaction using the private key.
    // TODO: somehow we cannot get this.hash;
    // We don't call this function on the generation of Tx, but when the user wants to create
    signTx(privateKey: string): string {
        // We're checking if the public key could be generated by the given private key.
        // Because we want only the Sender of the tx be able to sign it.
        // Other users cannot sign tx other than their own.
        const publicKey = this.derivePublicKey(privateKey);
        if (publicKey !== this.sender) {
            throw new Error("Sender does not match with given keys.");
        }

        const signer = crypto.createSign('sha256');
        const hash = this.hash || ''; // PROD: Delete this carrot.
        signer.update(Buffer.from(hash));
        const signature = signer.sign(privateKey);
        return signature.toString('ascii');
    }

    // TODO: Move this to util files. Transaction hash, not yet signed by sender.
    calculateTxHash(): String {
        return crypto.createHash('sha256').update(this.sender + this.body + this.timestamp).digest('hex');
    }

    derivePublicKey(privateKey: string): string {
        try {
            const publicKey = crypto.createPublicKey(privateKey);
            return publicKey.export({ type: 'spki', format: 'pem' }).toString();
        } catch (error: any) {
            throw new Error('Failed to derive public key: ' + error.message);
        }
    }

}