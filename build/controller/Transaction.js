"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var crypto = require("crypto");
var forge = require('node-forge');
var Transaction = /** @class */ (function () {
    function Transaction(_sender, _body, privateKey) {
        this.sender = _sender;
        this.timestamp = Date.now();
        this.body = _body;
        // this.signature = this.sign2(privateKey);
        this.signature = this.signTx(privateKey);
        this.hash = this.calculateTxHash();
    }
    // We sign the transaction hash using private key.
    Transaction.prototype.sign = function (key) {
        if (key.getPublic('hex') !== this.sender)
            throw new Error("Sender does not match with given keys.");
        var sign = key.sign(this.hash, 'base64');
        return sign.toDER('hex');
    };
    // Sign a transaction using the private key.
    // TODO: somehow we cannot get this.hash;
    // We don't call this function on the generation of Tx, but when the user wants to create
    Transaction.prototype.signTx = function (privateKey) {
        // We're checking if the public key could be generated by the given private key.
        // Because we want only the Sender of the tx be able to sign it.
        // Other users cannot sign tx other than their own.
        var publicKey = this.derivePublicKey(privateKey);
        if (publicKey !== this.sender) {
            throw new Error("Sender does not match with given keys.");
        }
        var signer = crypto.createSign('sha256');
        var hash = this.hash || ''; // PROD: Delete this carrot.
        signer.update(Buffer.from(hash));
        var signature = signer.sign(privateKey);
        return signature.toString('ascii');
    };
    // TODO: Move this to util files. Transaction hash, not yet signed by sender.
    Transaction.prototype.calculateTxHash = function () {
        return crypto.createHash('sha256').update(this.sender + this.body + this.timestamp).digest('hex');
    };
    Transaction.prototype.derivePublicKey = function (privateKey) {
        try {
            var publicKey = crypto.createPublicKey(privateKey);
            return publicKey.export({ type: 'spki', format: 'pem' }).toString();
        }
        catch (error) {
            throw new Error('Failed to derive public key: ' + error.message);
        }
    };
    return Transaction;
}());
exports.default = Transaction;
